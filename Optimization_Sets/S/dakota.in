environment
  graphics
  tabular_data

variables
	continuous_design = 43
  	  initial_point    1.769  1.764  1.163  1.788  1.939  1.718  1.822  2.175  1.243  2.500  1.913  1.204  1.642  1.764  1.183  2.175  1.912  2.373  2.343  6.604  2.231  1.901  1.023  2.493  2.259  2.694  2.389  2.026  2.231  0.526  1.193  8.769
  	  lower_bounds     1.669  1.664  1.063  1.688  1.839  1.618  1.722  1.675  0.743  2.400  1.813  1.104  1.542  1.664  1.083  2.075  1.812  2.273  1.843  5.504  2.131  1.801  0.923  2.393  2.159  2.594  2.289  1.926  2.131  0.026  0.693  7.769
  	  upper_bounds     1.869  1.864  1.263  1.888  2.039  1.818  1.922  2.675  1.743  2.550  2.013  1.304  1.742  1.864  1.283  2.275  2.012  2.473  2.843  7.704  2.331  2.001  1.123  2.583  2.359  2.794  2.489  2.126  2.331  1.026  1.693  9.769
  	  descriptors   'DAKOTA_S_RC_1' 'DAKOTA_S_RC_2' 'DAKOTA_S_RC_3' 'DAKOTA_S_RC_4' 'DAKOTA_S_RC_5' 'DAKOTA_S_RC_6' 'DAKOTA_S_RC_7' 'DAKOTA_S_EP_1' 'DAKOTA_S_EP_2' 'DAKOTA_Sr_RC_1' 'DAKOTA_Sr_RC_2' 'DAKOTA_Sr_RC_3' 'DAKOTA_Sr_RC_4' 'DAKOTA_Sr_RC_5' 'DAKOTA_Sr_RC_6' 'DAKOTA_Sr_RC_7' 'DAKOTA_Sr_RC_8' 'DAKOTA_Sr_RC_9' 'DAKOTA_Sr_EP_1' 'DAKOTA_Sr_EP_2' 'DAKOTA_Ag_RC_1' 'DAKOTA_Ag_RC_2' 'DAKOTA_Ag_RC_3' 'DAKOTA_Ag_RC_4' 'DAKOTA_Ag_RC_5' 'DAKOTA_Ag_RC_6' 'DAKOTA_Ag_RC_7' 'DAKOTA_Ag_RC_8' 'DAKOTA_Ag_RC_9' 'DAKOTA_Ag_EP_1' 'DAKOTA_Ag_EP_2' 'DAKOTA_Ag_EP_3' 'DAKOTA_Ti_RC_1' 'DAKOTA_Ti_RC_2' 'DAKOTA_Ti_RC_3' 'DAKOTA_Ti_RC_4' 'DAKOTA_Ti_RC_5' 'DAKOTA_Ti_RC_6' 'DAKOTA_Ti_RC_7' 'DAKOTA_Ti_RC_8' 'DAKOTA_Ti_RC_9' 'DAKOTA_Ti_EP_1' 'DAKOTA_Ti_EP_2'

## You should have reasonable guesses for the lower and upper bounds of the variables
## Otherwise, algorithm may converge slowly or diverge completely

method
        moga ## Multi-Objective Genetic Algorithm
        max_iterations = 100 ## Dakota will stop if 100 generations reached (defaults)
        population_size = 400 ## 400 chromosomes in the initial generation, default = 50, larger No. needed if bad initial guesses (wide ranges of variables)
        max_function_evaluations = 5000 ## Default, max number of chromosomes tested
        initialization_type unique_random ## Default, creates first generation randomly such that each chomosome is unqiue, works best
        crossover_type ## How is crossover of parents performed to generate offspring
          multi_point_parameterized_binary = 2  ## This method works best; 2-point crossover performed
          crossover_rate = 0.4 ## Probability of crossover being performed to generate offspring; this value has been optimized (roughly)
        mutation_type offset_normal ## Select mutations based on Gaussian distribution around parent values, works slightly better than random mutation
          mutation_scale = 0.05 ## Standard deviation of mutation equal to 5% the range of the variable, works well, further optimization may be possible
          mutation_rate = 0.25  ## No. of mutations = 10% * population size * number of variables (each generation), low rate works well
        fitness_type domination_count ## Determine which designs to keep based on number of other designs which dominate it (default)
        replacement_type below_limit = 6 ## Only keep designs which are dominated by fewer than 6 other designs, default value, works well
          shrinkage_fraction = 0.25  ## Next generation must be at least 20% the size of the previous generation, small values work best here
        convergence_type metric_tracker ## Test convergence of objective functions (metric given by largest change in any objective function)
          percent_change = 1 num_generations = 10 ## Convergence acheived if less than 1% change occurs over ten consecutive generations (default)
        final_solutions = 10 ## Give 10 best solutions once run finishes, optimum value may depend on your problem, how many local minima exist
        output verbose ## Write details to log

interface
        asynchronous 
          evaluation_concurrency = 1 ## Keep this low to prevent overusage of CPU
        system
          analysis_driver = '$SCHRODINGER/run /home/szymansk/Optimization_Sets/analysis.py $PWD' ## In each work directory, run analysis.py
          parameters_file = 'params.in' ## In each work directory, write values of variables to params.in 
          results_file    = 'results.out' ## In each work directory, write values of objective functions
        work_directory directory_tag 
          named 'workdir_pp'

responses
        num_objective_functions = 18 ## Set this accordingly based on your calculation
        no_gradients ## No gradients needed for genetic algorithm
        no_hessians ## No hessians needed for genetic algorithm

