environment
  graphics
  tabular_data ## output variable and objective function values to dakota_tabular.dat

variables
	continuous_design = 53
  	  initial_point    2.372  1.615  0.816  1.695  1.643  1.976  1.917  2.167  2.105  5.904  1.408  1.382  1.095  0.916  1.144  1.164  1.001  1.155  2.153  2.680  1.979  1.784  1.235  1.708  1.747  1.922  2.046  4.339  10.998  
  	  lower_bounds     2.272  1.515  0.716  1.595  1.543  1.876  1.817  2.067  2.005  5.404  0.908  1.282  0.995  0.816  1.044  1.064  0.901  1.055  1.653  2.180  1.879  1.684  1.135  1.608  1.647  1.822  1.946  3.839  9.9980  
  	  upper_bounds     2.472  1.715  0.916  1.795  1.743  2.076  2.017  2.267  2.205  6.404  1.908  1.482  1.195  1.016  1.244  1.264  1.101  1.255  2.653  3.180  2.079  1.884  1.335  1.808  1.847  2.022  2.146  4.839  11.998  
  	  descriptors     'DAKOTA_Sc_RC_1' 'DAKOTA_Sc_RC_2' 'DAKOTA_Sc_RC_3' 'DAKOTA_Sc_RC_4' 'DAKOTA_Sc_RC_5' 'DAKOTA_Sc_RC_6' 'DAKOTA_Sc_RC_7' 'DAKOTA_Sc_RC_8' 'DAKOTA_Sc_RC_9' 'DAKOTA_Sc_EP_1' 'DAKOTA_Sc_EP_2' 'DAKOTA_N_RC_1' 'DAKOTA_N_RC_2' 'DAKOTA_N_RC_3' 'DAKOTA_N_RC_4' 'DAKOTA_N_RC_5' 'DAKOTA_N_RC_6' 'DAKOTA_N_RC_7' 'DAKOTA_N_EP_1' 'DAKOTA_N_EP_2' 'DAKOTA_P_RC_1' 'DAKOTA_P_RC_2' 'DAKOTA_P_RC_3' 'DAKOTA_P_RC_4' 'DAKOTA_P_RC_5' 'DAKOTA_P_RC_6' 'DAKOTA_P_RC_7' 'DAKOTA_P_EP_1' 'DAKOTA_P_EP_2' 'DAKOTA_Sb_RC_1' 'DAKOTA_Sb_RC_2' 'DAKOTA_Sb_RC_3' 'DAKOTA_Sb_RC_4' 'DAKOTA_Sb_RC_5' 'DAKOTA_Sb_RC_6' 'DAKOTA_Sb_RC_7' 'DAKOTA_Sb_RC_8' 'DAKOTA_Sb_RC_9' 'DAKOTA_Sb_EP_1' 'DAKOTA_Sb_EP_2' 'DAKOTA_Sb_EP_3' 'DAKOTA_Pt_RC_1' 'DAKOTA_Pt_RC_2' 'DAKOTA_Pt_RC_3' 'DAKOTA_Pt_RC_4' 'DAKOTA_Pt_RC_5' 'DAKOTA_Pt_RC_6' 'DAKOTA_Pt_RC_7' 'DAKOTA_Pt_RC_8' 'DAKOTA_Pt_RC_9' 'DAKOTA_Pt_EP_1' 'DAKOTA_Pt_EP_2' 'DAKOTA_Pt_EP_3'

## You should have reasonable guesses for the lower and upper bounds of the variables
## Otherwise, algorithm may converge very slowly
## For single elements, a wide range of values may be tested and algorithm should converge at a reasonable rate
## However, for binaries (hence many variables), you should use a more narrow range
## Initial estimates may be taken from previously optimized values of constituent elements

method
        moga ## Multi-Objective Genetic Algorithm
        max_iterations = 100 ## Dakota will stop if 100 generations reached (defaults)
        population_size = 250 ## 250 chromosomes in the initial generation, default = 50, larger No. needed if bad initial guesses (wide ranges of variables)
        max_function_evaluations = 5000 ## Default, max number of chromosomes tested
        initialization_type unique_random ## Default, creates first generation randomly such that each chomosome is unqiue, works best
        crossover_type ## How is crossover of parents performed to generate offspring
          multi_point_parameterized_binary = 2  ## This method works best; 2-point crossover performed
          crossover_rate = 0.4 ## Probability of crossover being performed to generate offspring; this value has been optimized (roughly)
        mutation_type offset_normal ## Select mutations based on Gaussian distribution around parent values, works slightly better than random mutation
          mutation_scale = 0.05 ## Standard deviation of mutation equal to 5% the range of the variable, works well, further optimization may be possible
          mutation_rate = 0.2  ## No. of mutations = 10% * population size * number of variables (each generation), low rate works well
        fitness_type domination_count ## Determine which designs to keep based on number of other designs which dominate it (default)
        replacement_type below_limit = 6 ## Only keep designs which are dominated by fewer than 6 other designs, default value, works well
          shrinkage_fraction = 0.30  ## Next generation must be at least 30% the size of the previous generation, small values work best here
        convergence_type metric_tracker ## Test convergence of objective functions (metric given by largest change in any objective function)
          percent_change = 1 num_generations = 10 ## Convergence acheived if less than 1% change occurs over ten consecutive generations (default)
        final_solutions = 10 ## Give 10 best solutions once run finishes, optimum value may depend on your problem, how many local minima exist
        output verbose ## Write details to log

interface
        asynchronous 
          evaluation_concurrency = 1 ## Keep this low to prevent overusage of CPU
        system
          analysis_driver = '$SCHRODINGER/run /home/szymansk/Optimization_Sets/analysis.py $PWD' ## In each work directory, run analysis.py
          parameters_file = 'params.in' ## In each work directory, write values of variables to params.in 
          results_file    = 'results.out' ## In each work directory, write values of objective functions
        work_directory directory_tag 
          named 'workdir_pp'

responses
	num_objective_functions = 20 ## Set this accordingly based on your calculation
	no_gradients ## No gradients needed for genetic algorithm
        no_hessians ## No hessians needed for genetic algorithm
