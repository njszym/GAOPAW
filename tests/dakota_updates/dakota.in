environment
  graphics
  tabular_data ## output variable and objective function values to dakota_tabular.dat

variables
    continuous_design =  27
    initial_point =  1.797 1.617 1.617 1.91 2.092 1.988 1.98 6.728 2.167 1.352 1.267 0.819 1.311 1.378 1.749 1.398 11.439 7.272 1.604 1.203 1.316 1.444 1.391 1.352 1.566 4.463 5.822
    lower_bounds =  1.707 1.536 1.536 1.814 1.987 1.889 1.881 6.392 2.059 1.284 1.204 0.778 1.245 1.309 1.662 1.328 10.867 6.908 1.524 1.143 1.25 1.372 1.321 1.284 1.488 4.24 5.531
    upper_bounds =  1.887 1.698 1.698 2.006 2.197 2.087 2.079 7.064 2.275 1.42 1.33 0.86 1.377 1.447 1.836 1.468 12.011 7.636 1.684 1.263 1.382 1.516 1.461 1.42 1.644 4.686 6.113
    descriptors =  "DAKOTA_Si_RC_1" "DAKOTA_Si_RC_2" "DAKOTA_Si_RC_3" "DAKOTA_Si_RC_4" "DAKOTA_Si_RC_5" "DAKOTA_Si_RC_6" "DAKOTA_Si_RC_7" "DAKOTA_Si_EP_1" "DAKOTA_Si_EP_2" "DAKOTA_C_RC_1" "DAKOTA_C_RC_2" "DAKOTA_C_RC_3" "DAKOTA_C_RC_4" "DAKOTA_C_RC_5" "DAKOTA_C_RC_6" "DAKOTA_C_RC_7" "DAKOTA_C_EP_1" "DAKOTA_C_EP_2" "DAKOTA_O_RC_1" "DAKOTA_O_RC_2" "DAKOTA_O_RC_3" "DAKOTA_O_RC_4" "DAKOTA_O_RC_5" "DAKOTA_O_RC_6" "DAKOTA_O_RC_7" "DAKOTA_O_EP_1" "DAKOTA_O_EP_2"

## You should have reasonable guesses for the lower and upper bounds of the variables
## Otherwise, algorithm may converge very slowly
## For single elements, a wide range of values may be tested and algorithm should converge at a reasonable rate
## However, for binaries (hence many variables), you should use a more narrow range
## Initial estimates may be taken from previously optimized values of constituent elements

method
        moga ## Multi-Objective Genetic Algorithm
        max_iterations = 100 ## Dakota will stop if 100 generations reached (default)
        population_size = 500 ## chromosomes in the initial generation
        max_function_evaluations = 50000 ## Max number of chromosomes tested
        initialization_type unique_random ## Default, creates first generation randomly such that each chomosome is unqiue
        crossover_type ## How is crossover of parents performed to generate offspring
          multi_point_parameterized_binary = 2  ## This method works best; 2-point crossover performed
          crossover_rate = 0.4 ## Probability of crossover being performed to generate offspring; this value has been optimized (roughly)
        mutation_type offset_normal ## Select mutations based on Gaussian distribution around parent values, works slightly better than random mutation
          mutation_scale = 0.05 ## Standard deviation of mutation equal to 5% the range of the variable
          mutation_rate = 0.1  ## No. of mutations = 10% * population size * number of variables (each generation), low rate works well
        fitness_type domination_count ## Determine which designs to keep based on number of other designs which dominate it (default)
        replacement_type below_limit = 6 ## Only keep designs which are dominated by fewer than 6 other designs, default value, works well
          shrinkage_fraction = 0.25  ## Next generation must be at least 25% the size of the previous generation, small values work best here
        convergence_type metric_tracker ## Test convergence of objective functions (metric given by largest change in any objective function)
          percent_change = 1 num_generations = 10 ## Convergence acheived if less than 1% change occurs over ten consecutive generations (default)
        final_solutions = 10 ## Give 10 best solutions once run finishes, optimum value may depend on your problem, how many local minima exist
        output verbose ## Write details to log

interface
        asynchronous 
          evaluation_concurrency = 1 ## Depends on number of cores you plan to run on; +1 concurrency for each additional 4 cores
        system
          analysis_driver = '$SCHRODINGER/run /scr/szymansk/gaopaw/analysis.py $PWD' ## In each work directory, run analysis.py
          parameters_file = 'params.in' ## In each work directory, write values of variables to params.in 
          results_file    = 'results.out' ## In each work directory, write values of objective functions
        work_directory directory_tag 
          named 'workdir_pp' ## Uncomment if you'd like to save all working directories: file_save directory_save (takes up lots of space)

responses
    num_objective_functions =  14
	no_gradients ## No gradients needed for genetic algorithm
        no_hessians ## No hessians needed for genetic algorithm
    descriptors =  'Si_elemental_log' 'Si_FCC_lattice_constant' 'Si_BCC_lattice_constant' 'Si_BCC_phonon_frequency' 'C_elemental_log' 'C_FCC_lattice_constant' 'C_BCC_lattice_constant' 'O_elemental_log' 'O_FCC_lattice_constant' 'O_BCC_lattice_constant' 'SiO_RS_lattice_constant' 'SiC_ZB_lattice_constant' 'SiC_ZB_band_gap' 'SiC_ZB_eos'
